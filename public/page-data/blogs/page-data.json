{"componentChunkName":"component---src-pages-blogs-js","path":"/blogs/","result":{"data":{"allStrapiBlog":{"edges":[{"node":{"blog_title":"Optimizing Java based Lambda Functions using GraalVM & Micronaut for Spring","content":"# Introduction\n\n-----------------------------------------> Show Image of Application Flow <----------------------------------------------------------\n\n\nTLDR;\nYou can Download the Project by cloning this this repo [https://github.com/dhruvaj-patil/micronaut-lambda-graalvm.git](https://github.com/dhruvaj-patil/micronaut-lambda-graalvm)\n\n**For Running the Application Locally**:\nIn the command line type\n```\nsh sam-local.sh\n```\n\n**For Deploying it on Cloud**:\n\n```\naws s3 mb s3://<s3-bucket-name>\n\naws cloudformation package --template-file sam-native.yaml  --output-template-file packaged-sam.yaml --s3-bucket <s3-bucket-name>\n\naws cloudformation deploy --template-file ./packaged-sam.yaml  --stack-name <stack-name> --capabilities CAPABILITY_IAM\n\n```\n\n\n## Break down of Application:\n\n### Main Class File:\n\nFilename: *Application.java*\n```\npackage com.amazonaws.micronaut.demo;\n\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\nimport ch.qos.logback.classic.Level;\nimport ch.qos.logback.classic.Logger;\nimport io.micronaut.runtime.Micronaut; \n\n@SpringBootApplication\npublic class Application {\n\n    public static void main(String[] args) {\n        Logger rootLogger = (ch.qos.logback.classic.Logger)org.slf4j.LoggerFactory.getLogger(org.slf4j.Logger.ROOT_LOGGER_NAME);\n        rootLogger.setLevel(Level.TRACE);\n        Micronaut.run(Application.class);\n    }\n}\n\n```\n**slf4j** :  The Simple Logging Facade for Java (SLF4J) serves as a simple facade or abstraction for various logging frameworks. Basically like hibernate, it can be used with any logging framework but has specific methods that translate to these frameworks.\n\n**logback** : Using it with SLF4J for logging the application\n\n**[Micronaut.run](https://docs.micronaut.io/snapshot/api/)** : The main entry point for running a Micronaut application. Run the application for the given arguments.\n\n\n### Controller:\n\nFilename: *EmpController.java*\n```\npackage com.amazonaws.micronaut.demo;\n\nimport com.amazonaws.micronaut.demo.model.Emp;\nimport com.amazonaws.micronaut.demo.model.EmpData;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\n\nimport java.util.Optional;\nimport java.util.UUID;\n\n@RestController\n@EnableWebMvc\npublic class EmpController {\n\n    private EmpData empData;\n\n    @Autowired\n    public EmpController(EmpData emData) {\n        empData = emData;\n    }\n\n\n    @RequestMapping(path = \"/emp\", method = RequestMethod.POST)\n    public Emp createEmp(@RequestBody Emp newEmp) {\n        if(newEmp.getName() == null || newEmp.getDept() == null){\n            return null;\n        }\n\n        Emp addEmp = newEmp;\n        addEmp.setEmp_id(UUID.randomUUID().toString());\n        return addEmp;\n    }\n\n\n    @RequestMapping(path =  \"/sayhello \", method = RequestMethod.GET)\n    public String sayHello(){\n        return  \"Hey Hi Bro\";\n    }\n\n    @RequestMapping(path = \"/emp/{emp_id}\", method = RequestMethod.GET)\n    public Emp singleEmp(@RequestParam(\"emp_id\") String empid) {\n        Emp singleEmp = new Emp();\n        singleEmp.setDept(empData.getRandomDept());\n        singleEmp.setName(empData.getRandomName());\n        singleEmp.setEmp_id(empid);\n        singleEmp.setSalary(54000);\n\n        return  singleEmp;\n    }\n\n    @RequestMapping(path = \"/emps\", method = RequestMethod.GET)\n    public Emp[] getEmpList(@RequestParam(\"limit\") Optional<Integer> limit){\n        int queryLimit = 10;\n        if (limit.isPresent()) {\n            queryLimit = limit.get();\n        }\n\n        Emp[] outputEmps = new Emp[queryLimit];\n        for(int i =0 ;i< queryLimit; i++){\n            Emp newEmp = new Emp();\n            newEmp.setEmp_id(UUID.randomUUID().toString());\n            newEmp.setName(empData.getRandomName());\n            newEmp.setDept(empData.getRandomDept());\n            newEmp.setSalary(200000);\n\n            outputEmps[i] = newEmp;\n        }\n\n        return outputEmps;\n    }\n}\n\n```\n\nOur Controller is just like any other Spring Based Controller.\n\n**@RestController**: It's a convenience annotation that combines @Controller and @ResponseBody – which eliminates the need to annotate every request handling method of the controller class with the @ResponseBody annotation. The @ResponseBody basically converts POJO to JSON, when sending back the response.\n- Also, Only @RestController semantics are supported, by a Micronaut Application.\n\n**@EnableWebMvc**: The @EnableWebMvc annotation is used for enabling Spring MVC in an application and works by importing the Spring MVC Configuration from WebMvcConfigurationSupport.\n\nBehind the scene, Micronaut works in a very different way, our Spring MVC controllers are computed into Micronaut controllers at compilation time. [For more Info click on the link](https://micronaut-projects.github.io/micronaut-spring/latest/guide/index.html#springMvc)\n\n\n\n### BEAN: \n\nFilename: *Emp.java*\n```\npackage com.amazonaws.micronaut.demo.model;\n\n\nimport io.micronaut.core.annotation.Introspected;\n\n@Introspected\npublic class Emp {\n    private String name, dept, emp_id;\n    private float salary;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getDept() {\n        return dept;\n    }\n\n    public void setDept(String dept) {\n        this.dept = dept;\n    }\n\n    public String getEmp_id() {\n        return emp_id;\n    }\n\n    public void setEmp_id(String emp_id) {\n        this.emp_id = emp_id;\n    }\n\n    public float getSalary() {\n        return salary;\n    }\n\n    public void setSalary(float salary) {\n        this.salary = salary;\n    }\n\n}\n\n```\n\n\n\n**@Introspected**: It is a  **io.micronaut.core** annotation that indicates a type should produce a BeanIntrospection at compilation time. A BeanIntrospection is the result of the compile-time computation of beans properties and annotation metadata.\n\n\n\n### Dummy Repository: \n\nFilename: *EmpData.java*\n```\n\npackage com.amazonaws.micronaut.demo.model;\n\nimport org.springframework.stereotype.Component;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ThreadLocalRandom;\n\n@Component\npublic class EmpData {\n    private static List<String> dept = new ArrayList<>();\n    static {\n        dept.add(\"CS\");\n        dept.add(\"Frontend\");\n        dept.add(\"DevOps\");\n        dept.add(\"Finance\");\n        dept.add(\"HR\");\n        dept.add(\"HRKC\");\n    }\n\n    private static List<String> empNames = new ArrayList<>();\n    static {\n        empNames.add(\"Dhruvaj\");\n        empNames.add(\"Devashish\");\n        empNames.add(\"Kunal\");\n        empNames.add(\"Indrajeet\");\n        empNames.add(\"Tripti\");\n        empNames.add(\"Radha\");\n        empNames.add(\"Aziz\");\n        empNames.add(\"Aman\");\n        empNames.add(\"Frenny\");\n        empNames.add(\"Zainul\");\n        empNames.add(\"Abhay\");\n        empNames.add(\"Harsh\");\n        empNames.add(\"Jack\");\n        empNames.add(\"Sadie\");\n        empNames.add(\"Toby\");\n        empNames.add(\"Chloe\");\n        empNames.add(\"Cody\");\n        empNames.add(\"Bailey\");\n        empNames.add(\"Buster\");\n        empNames.add(\"Lola\");\n        empNames.add(\"Duke\");\n        empNames.add(\"Zoe\");\n        empNames.add(\"Cooper\");\n        empNames.add(\"Abby\");\n        empNames.add(\"Riley\");\n        empNames.add(\"Ginger\");\n        empNames.add(\"Harley\");\n        empNames.add(\"Roxy\");\n        empNames.add(\"Bear\");\n        empNames.add(\"Gracie\");\n        empNames.add(\"Tucker\");\n        empNames.add(\"Coco\");\n        empNames.add(\"Murphy\");\n        empNames.add(\"Sasha\");\n        empNames.add(\"Lucky\");\n        empNames.add(\"Lily\");\n        empNames.add(\"Oliver\");\n        empNames.add(\"Angel\");\n        empNames.add(\"Sam\");\n        empNames.add(\"Shubham\");\n        empNames.add(\"Oscar\");\n        empNames.add(\"Emma\");\n        empNames.add(\"Teddy\");\n        empNames.add(\"Annie\");\n        empNames.add(\"Winston\");\n        empNames.add(\"Rosie\");\n    }\n\n\n    public static List<String> getDept() {\n        return dept;\n    }\n\n    public static void setDept(List<String> dept) {\n        EmpData.dept = dept;\n    }\n\n    public static List<String> getEmpNames() {\n        return empNames;\n    }\n\n    public static void setEmpNames(List<String> empNames) {\n        EmpData.empNames = empNames;\n    }\n\n    public String getRandomName(){\n        return empNames.get(ThreadLocalRandom.current().nextInt(0, empNames.size() - 1));\n    }\n\n    public String getRandomDept() {\n        return dept.get(ThreadLocalRandom.current().nextInt(0, dept.size() -1));\n    }\n}\n```\n\n\n**@Component**: Indicates that an annotated class is a \"component\". Such classes are considered as candidates for auto-detection when using annotation-based configuration and classpath scanning.\n\n### Build Tool(Gradle):\n\nFilename: *build.gradle*:\n```\nplugins {\n    id \"java\"\n    id \"com.github.johnrengelman.shadow\" version \"5.0.0\"\n    id \"application\"\n    id \"net.ltgt.apt-eclipse\" version \"0.21\"\n    id \"org.springframework.boot\" version \"2.1.12.RELEASE\"\n    id \"io.spring.dependency-management\" version \"1.0.6.RELEASE\"\n}\n\nversion \"0.1\"\ngroup \"graal.spring.demo\"\n\nrepositories {\n    mavenCentral()\n    maven { url \"https://jcenter.bintray.com\" }\n}\n\nconfigurations {\n    // for dependencies that are needed for development only\n    developmentOnly \n}\n\ndependencies {\n    annotationProcessor platform(\"io.micronaut:micronaut-bom:$micronautVersion\")\n    annotationProcessor \"io.micronaut:micronaut-graal\"\n    annotationProcessor \"io.micronaut:micronaut-inject-java\"\n    annotationProcessor \"io.micronaut:micronaut-validation\"\n    annotationProcessor \"io.micronaut.spring:micronaut-spring-boot\"\n    annotationProcessor \"io.micronaut.spring:micronaut-spring-boot-annotation\"\n    annotationProcessor \"io.micronaut.spring:micronaut-spring-web-annotation\"\n    testAnnotationProcessor \"io.micronaut.spring:micronaut-spring-web-annotation\"\n\n    compileOnly \"com.oracle.substratevm:svm\" //Provides SubstrateVM which includes runtime components like he deoptimizer, garbage collector, thread scheduling etc. The resulting program has faster startup time and lower runtime memory overhead compared to a Java VM. We pass values to args to the native-image using the file native-image.properties to finetune the native-image generation.\n    implementation platform(\"io.micronaut:micronaut-bom:$micronautVersion\")\n    implementation \"io.micronaut:micronaut-http-client\"\n    implementation \"io.micronaut:micronaut-inject\"\n    implementation \"io.micronaut:micronaut-validation\"\n    implementation \"io.micronaut:micronaut-runtime\" //micronaut runtime gives us io.micronaut.function.aws.runtime.MicronautLambdaRuntime(native-image.properties) for running the application on aws Lambda\n\n    // To deploy your Micronaut function as a GraalVM Native Image you need to select a custom runtime. -> https://micronaut-projects.github.io/micronaut-aws/latest/guide/index.html#applicationtyperuntimedependencies\n    implementation(\"io.micronaut.aws:micronaut-function-aws-custom-runtime:1.3.2\") { //for using custom runtime on aws lambda. A runtime is a program that runs a Lambda function’s handler method when the function is invoked. You can include a runtime in your function’s deployment package in the form of an executable file named bootstrap\n        exclude group: \"com.fasterxml.jackson.module\", module: \"jackson-module-afterburner\"\n    }\n    implementation(\"io.micronaut.aws:micronaut-function-aws-api-proxy:1.3.2\") { // for using aws-api-proxy \n        exclude group: \"com.fasterxml.jackson.module\", module: \"jackson-module-afterburner\"\n    }\n    developmentOnly \"io.micronaut:micronaut-http-server-netty\"\n    runtimeOnly \"ch.qos.logback:logback-classic:1.2.3\"\n    testAnnotationProcessor platform(\"io.micronaut:micronaut-bom:$micronautVersion\")\n    testAnnotationProcessor \"io.micronaut:micronaut-inject-java\"\n    testImplementation platform(\"io.micronaut:micronaut-bom:$micronautVersion\")\n    testImplementation \"org.junit.jupiter:junit-jupiter-api\"\n    testImplementation \"io.micronaut.test:micronaut-test-junit5\"\n    testRuntimeOnly \"org.junit.jupiter:junit-jupiter-engine\"\n\n    // spring support\n    compile(\"org.springframework.boot:spring-boot-starter-web\")\n    runtime(\"io.micronaut.spring:micronaut-spring-boot:1.0.1\")\n    runtime(\"io.micronaut.spring:micronaut-spring-web:1.0.1\")\n}\n\ntest.classpath += configurations.developmentOnly\n\nmainClassName = \"graal.spring.demo.Application\"\n// use JUnit 5 platform\ntest {\n    useJUnitPlatform()\n}\n\nshadowJar {\n    mergeServiceFiles()\n}\n\nrun.classpath += configurations.developmentOnly\nrun.jvmArgs('-noverify', '-XX:TieredStopAtLevel=1', '-Dcom.sun.management.jmxremote')\ntasks.withType(JavaCompile){\n    options.encoding = \"UTF-8\"\n    options.compilerArgs.add('-parameters')\n}\n\n```\n\n### This is where the magic happens:\n\nFilename: *build.gradle*\n\n**annotationProcessor(\"io.micronaut:micronaut-graal\")**: Is an annotation processor to generate the reflection and resources information at compile time. It has compile dependencies on \nio.micronaut:micronaut-runtime and org.slf4j » slf4j-api.\n\n**compileOnly \"com.oracle.substratevm:svm\"**:  Provides SubstrateVM which includes runtime components like he deoptimizer, garbage collector, thread scheduling etc. The resulting program has faster startup time and lower runtime memory overhead compared to a Java VM. We pass values to args to the native-image using the file native-image.properties to finetune the native-image generation.\n\n**implementation \"io.micronaut:micronaut-runtime\"**: micronaut runtime gives us io.micronaut.function.aws.runtime.MicronautLambdaRuntime(native-image.properties) for running the application on aws Lambda\n\n\nTo deploy your Micronaut function as a GraalVM Native Image you need to select a [custom runtime]( https://micronaut-projects.github.io/micronaut-aws/latest/guide/index.html#applicationtyperuntimedependencies).\n**implementation(\"io.micronaut.aws:micronaut-function-aws-custom-runtime:1.3.2\")** :for using custom runtime on aws lambda. A runtime is a program that runs a Lambda function’s handler method when the function is invoked. You can include a runtime in your function’s deployment package in the form of an executable file named bootstrap\n\n**implementation(\"io.micronaut.aws:micronaut-function-aws-api-proxy:1.3.2\")**:for using aws-api-proxy \n\n\n\nNow we create a Docker container to run the the __emp-data-0.1-all.jar__ file from the *build/libs* folder on the SVM(SubstrateVM).\n\n\n### DOCKERFILE\n\nFilename: *Dockerfile*\n```\nFROM amazonlinux:2017.03.1.20170812 as graalvm \n# install graal to amazon linux base container.\nENV LANG=en_US.UTF-8\n\n#Things required by graal for installation(https://www.graalvm.org/reference-manual/native-image/)\nRUN yum install -y gcc gcc-c++ libc6-dev  zlib1g-dev curl bash zlib zlib-devel zip  \\\n#    && yum install -y libcxx libcxx-devel llvm-toolset-7 \\\n    && rm -rf /var/cache/yum\n\n# Variables\nENV GRAAL_VERSION 19.2.0.1\nENV GRAAL_FILENAME graalvm-ce-linux-amd64-${GRAAL_VERSION}.tar.gz\n\n# Download Image from github\nRUN curl -4 -L https://github.com/oracle/graal/releases/download/vm-${GRAAL_VERSION}/graalvm-ce-linux-amd64-${GRAAL_VERSION}.tar.gz -o /tmp/${GRAAL_FILENAME}\n\n# tar = unzip | -C = change directory | mv move\nRUN tar -zxvf /tmp/${GRAAL_FILENAME} -C /tmp \\\n    && mv /tmp/graalvm-ce-${GRAAL_VERSION} /usr/lib/graalvm\n\n# remove folder/tmp\nRUN rm -rf /tmp/*\n\n#install graalVM\nRUN /usr/lib/graalvm/bin/gu install native-image\n\n# Copy the from local script/graalvm-build.sh -> docker container's bin folder.\nADD scripts/graalvm-build.sh /usr/local/bin/\n\n# Make the file an executable\nRUN chmod +x /usr/local/bin/graalvm-build.sh\nVOLUME [\"/func\"]\nWORKDIR /func\nENTRYPOINT [\"/usr/local/bin/graalvm-build.sh\"]\n```\n\nWe create a container using Dockerfile and install GraalVm so that we can use SubstrateVM to convert our java-micronaut code, which is compiled AOT to a native binary. It is hard for SVM to compile codes which are reflection-based.\n\n### Building a native binary using SubstrateVM\n\nFilename: *graalvm-build.sh*\n\n```\n#!/bin/sh\necho \"Startin GraalVM build\"\n\n/usr/lib/graalvm/bin/native-image -H:+TraceClassInitialization --initialize-at-build-time=reactor.core.publisher.Mono --initialize-at-build-time=reactor.core.publisher.Flux --no-fallback --no-server -cp /func/build/libs/emp-data-*.jar\nrm -rf /func/native-image/*\n\nchmod 755 /func/server\nmv /func/server /func/native-image/server\ncp /func/scripts/bootstrap /func/native-image/bootstrap\ncd /func/native-image && zip -j function.zip bootstrap server\n```\n\nThe native-image command line needs to provide the classpath for all classes using the familiar option from the java launcher: -cp is followed by a list of directories or .jar files, separated by :. The name of the class containing the main method is the last argument, or you can use -jar and provide a .jar file that specifies the main method in its manifest.\n\nThe syntax of the native-image command is:\n\n   - **native-image [options] class** to build an executable file for a class in the current working directory. Invoking it executes the native-compiled code of that class.\n\n   - **native-image [options] -jar jarfile** to build an image for a jar file.\n\n\n**--initialize-at-build-time**:  A comma-separated list of packages and classes (and implicitly all of their superclasses) that are initialized during image generation. An empty string designates all packages\n\n\n**reactor.core.publisher.Flux**:  A Reactive Streams Publisher with rx operators that emits 0 to N elements, and then completes (successfully or with an error).\n\nIt is intended to be used in implementations and return types. Input parameters should keep using raw Publisher as much as possible.\n\nIf it is known that the underlying Publisher will emit 0 or 1 element, **reactor.core.publisher.Mono** should be used instead.\n\n![flux.png](https://res.cloudinary.com/dhruvaj/image/upload/v1600058698/flux_8afb911678.png)\n\n**--no-fallback**: build stand-alone image or report failure\n\n\nAll this\n\n\n### MAKING THE APPLICATION RUN MICRONAUTLAMBDA RUNTIME TO SERVE USING LAMBDA RUNTIME\n\nFilename: *src/main/resources/META-INF/native-image/graal.spring.demo/graal-spring-demo-application/native-image.properties*\n\n```\nArgs = -H:IncludeResources=application.yml|log4j2.xml \\\n       -H:Name=server \\\n       -H:-AllowVMInspection \\\n       -H:Class=io.micronaut.function.aws.runtime.MicronautLambdaRuntime #Provides us with MicronautRuntime to Run the application on Lambda\n\n```\n\n **-H:Class=io.micronaut.function.aws.runtime.MicronautLambdaRuntime**: Provides us with MicronautRuntime to Run the application on Lambda\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","id":"Blog_5f4254ac5e327300172eaa3e","published_on":"23-Aug-2020","tag":"Programming","take_away":"https://github.com/dhruvaj-patil/micronaut-lambda-graalvm","ImageBg":{"childImageSharp":{"fixed":{"src":"/static/eb612baacfb8c06e9112b0f97e15d0dc/f11e0/8f65ad38284e90783855f3af8e063219.jpg"}}}}},{"node":{"blog_title":"DS Global Trade Static Website","content":"## STACK\n\n- HTML \n- CSS\n- Bootstrap\n- Javascript","id":"Blog_5f7ab3ac67a88e001752071f","published_on":"16-Jul-2019","tag":"Programming","take_away":"http://dsglobaltrade.com/","ImageBg":{"childImageSharp":{"fixed":{"src":"/static/dc20e0081a1611951fa01709c445ae56/b5e6b/f6148eee2da6847055d2edd22e451f70.png"}}}}},{"node":{"blog_title":"My Personal Website","content":"### Development Stack\n\n- Gatsby (React)\n- SCSS\n- Heroku (Server)\n- MongoDB Atlas Cloud DB (DB)\n- Strapi (Node Based Headless CMS)\n\n### Design Stack\n-  Figma (Design)","id":"Blog_5f7ab64267a88e0017520722","published_on":"10-Jun-2020","tag":"Programming","take_away":"https://dhruvaj.com/","ImageBg":{"childImageSharp":{"fixed":{"src":"/static/602db74a8d79e9c863d09c85d71f3c8f/b5e6b/d789d192c5002a246d1ae2c28ba00251.png"}}}}}]}},"pageContext":{}},"staticQueryHashes":["3649515864"]}